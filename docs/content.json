{"meta":{"title":"Xander's blog","subtitle":"Android blog","description":"My blog for Android","author":"Xander Wang","url":"https://xanderwang.github.io/android-note","root":"/android-note/"},"pages":[{"title":"关于我","date":"2021-02-24T04:52:56.000Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"about/index.html","permalink":"https://xanderwang.github.io/android-note/about/index.html","excerpt":"","text":"Github: https://github.com/XanderWang CSDN: https://blog.csdn.net/wxy318 Mail: &#52;&#50;&#48;&#x36;&#52;&#x30;&#55;&#x36;&#51;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d; 微信:"},{"title":"归档","date":"2021-02-26T06:39:39.531Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"archives/index.html","permalink":"https://xanderwang.github.io/android-note/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-02-26T06:39:39.531Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"categories/index.html","permalink":"https://xanderwang.github.io/android-note/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-05-18T05:27:50.000Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"tags/index.html","permalink":"https://xanderwang.github.io/android-note/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"利用 GitHub 搭建自己的个人博客","slug":"利用 GitHub 搭建自己的个人博客","date":"2021-02-25T14:41:00.000Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"2021/02/25/利用 GitHub 搭建自己的个人博客/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/25/%E5%88%A9%E7%94%A8%20GitHub%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"先看下预览图吧。 先说下方案: GitHub Page + GitHub Action + hexo &amp; 配套主题 GitHub Page这个都不陌生吧，注册 GitHub 账号后，可以帮你托管你的 repository 下的静态网页，比如我有个 repository 叫 android-note ，我的 github 账号叫 xanderwang ，那么我的 android-note 托管后，访问地址就是： https://xander.github.io/android-note 托管后，如果我每次写了新的文章后，我把最新的静态 blog 上传上来，那么就可以更新自己的博客。 如果每次都可以自动编译和上传 blog 静态网页，那就很省事了。事实上，这个是可以做到的，具体细节后面再说。我们先看看如何托管我们的 repository 到 GitHub Page 。 最开始接触到 GitHub Page 的时候，看文章都是说需要新建一个和自己用户名同名的 repository ，然后往这个 repository 根目录里面上传静态 blog 网页，然后托管。 后来我发现不是这样，至少目前不是这样，我发现任意的 repository 都可以托管，只需要做一些特别的设置，如何设置呢？ 找到你的 repository ，然后 settings -&gt; GitHub Pages -&gt; Source -&gt; 选择分支和静态博客的目录(貌似只能选 / 或者 /doc) 到这里 GitHub 托管就设置好了。按照之前的规则你就可以访问你托管 blog 了。 GitHub Action刚刚说了，如果有个自动编译和上传 blog 的工具或者平台，每次我们写好 blog 后，自动帮我们编译上传好，那我们就可以省很多事。GitHub Action 正好可以做这个的，而且可以和 GitHub 无缝对接。那如何使用呢？ 很简单，只需要在你的 repository 里面新建 .github 文件夹，然后在里面新建 .workflows 文件夹，然后在里面新建 build.yml 文件(build 可以换成任意你喜欢的)，然后 GitHub Action 功能就开通了。这个时候， repository 下的目录结构大概是 . ├── .github │ └── workflows │ └── build.yml 现在介绍下如何配置 build.yml 文件 name: Xander&#39;s Blog Task # 在push **.md **.yml **.yaml **.sh 文件后执行任务 on: #配置任务执行时机 # Trigger the workflow on push or pull request, # but only for the master branch push: # branches: # - master paths: - &#39;**.md&#39; - &#39;**.yml&#39; - &#39;**.yaml&#39; - &#39;**.sh&#39; jobs: # 配置具体任务 build: # runs-on: macOS-latest runs-on: ubuntu-latest steps: # 引用外部 Action, 拉取代码仓库到虚拟机工作目录 - name: chekout code uses: actions/checkout@v1 # 执行 .sh 脚本文件，很多的任务可以在这个脚本里面执行 - name: build note run: sh ./blog_config/build.sh ... 上面列出了主要的步骤和解释了，具体可以参考我的 repository 这里需要说明的是，如果你需要额外传一些参数，比如密码是的，你需要现在 repository 做一些设置，具体参考如下： settings -&gt; secrets -&gt; 新建一个 secret 然后在你的 build.yml 里面使用 steps: - name: Hello world action with: # Set the secret as an input super_secret: $&#123;&#123; secrets.SuperSecret &#125;&#125; env: # Or as an environment variable super_secret: $&#123;&#123; secrets.SuperSecret &#125;&#125; run: | example-command &quot;$super_secret&quot; 到这里自动编译和发布的工作就说完了，现在我们还缺什么？ hexo &amp; 配套主题前面说了托管和自动编译和发布，现在我们就差一个个性化的静态 blog 模板了，这里我选择的是 hexo &amp; 配套主题。 hexo这个是一个静态的博客构建软件，配合网络上的主题，可以比较方便构建出自己的博客，同时有大量的精美主题可以选择。 如何安装就不具体说了，不是很难，官网有很详细的教程。 点我直达 hexo 官网 hexo 配套主题主题的话，一般可以在 GitHub 上面找，我暂时用的 volantis，可以去官网看下这个主题的具体介绍和相关配置。 这里说下可能遇到的坑的， 这里说下 _config.yml ... # URL ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: https://xanderwang.github.io/android-note root: /android-note/ # 需要注意这里的配置，注意 url 和 root 的配置，如果不是用的 GitHub 同名 repository 托管的，都需要配置 # Directory public_dir: docs # 公共文件夹，这个文件夹用于存放生成的站点文件。 # public_dir 目录就是 hexo 编译后存放静态 html 的目录，在托管 GitHub Page 的时候注意选择这个目录。 ... 其他的配置就是主题配置了，这个建议按照注意的 repository 或者主题的 demo 去配置，每个主题都是不一样的，只能靠自己的折腾了。","categories":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xanderwang.github.io/android-note/tags/hexo/"},{"name":"Github Action","slug":"Github-Action","permalink":"https://xanderwang.github.io/android-note/tags/Github-Action/"},{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://xanderwang.github.io/android-note/tags/GitHub-Page/"}]},{"title":"写了个 Android 性能检测的库，还有人看性能相关的么","slug":"写了个 Android 性能检测的库，还有人看性能相关的么","date":"2021-02-24T14:41:00.000Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"2021/02/24/写了个 Android 性能检测的库，还有人看性能相关的么/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/24/%E5%86%99%E4%BA%86%E4%B8%AA%20Android%20%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E7%9A%84%E5%BA%93%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BA%BA%E7%9C%8B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B9%88/","excerpt":"","text":"简介由于本人工作需要，需要解决一些性能问题，虽然有 Profiler 、Systrace 等工具，但是无法实时监控，多少有些不方便，于是计划写一个能实时监控性能的小工具。经过学习大佬们的文章，最终完成了这个开源的性能实时检测库。初步能达到预期效果，这里做个记录，算是小结了。 开源库的地址是: https://github.com/XanderWang/performance 幸苦各位能给个小小的 star 鼓励下。 这个性能检测库，可以检测以下问题： UI 线程 block 检测。 App 的 FPS 检测。 线程的创建和启动监控以及线程池的创建监控。 IPC (进程间通讯)监控。 同时还实现了以下功能： 实时通过 logcat 打印检测到的问题。 保存检测到的信息到文件。 提供上报信息文件接口。 接入指南1 在 APP 工程目录下面的 build.gradle 添加如下内容。 dependencies &#123; // 必选 debugImplementation &quot;com.xander.performance:perf:0.1.12&quot; releaseImplementation &quot;com.xander.performance:perf-noop:0.1.12&quot; // hook 方案封装，必须添加 debugImplementation &quot;com.xander.performance:perf-hook:0.1.12&quot; // 以下是 hook 方案选择一个就好了。如果运行报错，就换另外一个，如果还是报错，就提个 issue // SandHook 方案，推荐添加。如果运行报错，可以替换为 epic 库。 debugImplementation &quot;com.xander.performance:perf-hook-sandhook:0.1.12&quot; // epic 方法。如果运行报错，可以替换为 SandHook。 // debugImplementation &quot;com.xander.performance:perf-hook-epic:0.1.12&quot; &#125; 2 APP 工程的 Application 类新增类似如下初始化代码。 Java 初始化示例 private void initPERF(final Context context) &#123; final PERF.LogFileUploader logFileUploader = new PERF.LogFileUploader() &#123; @Override public boolean upload(File logFile) &#123; return false; &#125; &#125;; PERF.init(new PERF.Builder() .checkUI(true, 100) // 检查 ui lock .checkIPC(true) // 检查 ipc 调用 .checkFps(true, 1000) // 检查 fps .checkThread(true) // 检查线程和线程池 .globalTag(&quot;test_perf&quot;) // 全局 logcat tag ,方便过滤 .cacheDirSupplier(new PERF.IssueSupplier&lt;File&gt;() &#123; @Override public File get() &#123; // issue 文件保存目录 return context.getCacheDir(); &#125; &#125;) .maxCacheSizeSupplier(new PERF.IssueSupplier&lt;Integer&gt;() &#123; @Override public Integer get() &#123; // issue 文件最大占用存储空间 return 10 * 1024 * 1024; &#125; &#125;) .uploaderSupplier(new PERF.IssueSupplier&lt;PERF.LogFileUploader&gt;() &#123; @Override public PERF.LogFileUploader get() &#123; // issue 文件上传接口 return logFileUploader; &#125; &#125;) .build()); &#125; kotlin 示例 private fun doUpload(log: File): Boolean &#123; return false &#125; private fun initPERF(context: Context) &#123; PERF.init(PERF.Builder() .checkUI(true, 100)// 检查 ui lock .checkIPC(true) // 检查 ipc 调用 .checkFps(true, 1000) // 检查 fps .checkThread(true)// 检查线程和线程池 .globalTag(&quot;test_perf&quot;)// 全局 logcat tag ,方便过滤 .cacheDirSupplier &#123; context.cacheDir &#125; // issue 文件保存目录 .maxCacheSizeSupplier &#123; 10 * 1024 * 1024 &#125; // issue 文件最大占用存储空间 .uploaderSupplier &#123; // issue 文件的上传接口实现 PERF.LogFileUploader &#123; logFile -&gt; doUpload(logFile) &#125; &#125; .build() ) &#125; 主要更新记录 0.1.12 线程创建的监控，加入 thread name 信息收集。同时接入 startup 库做必要的初始化，以及调整 mulit dex 的时候，配置文件找不到的问题。 0.1.11 优化 hook 方案的封装，通过 SandHook ,IPC 的监控可以按照耗时时间来检测。 0.1.10 FPS 的检测时间间隔从默认 2s 调整为 1s，同时支持自定义时间间隔。 0.1.9 优化线程池创建的监控。 0.1.8 初版发布，完成基本的功能。 不建议直接在线上使用这个库，在编写这个库，测试 hook 的时候，在不同的机器和 rom 上，会有不同的问题，这里建议先只在线下自测使用这个检测库。 原理介绍UI 线程 block 检测原理主要参考了 AndroidPerformanceMonitor 库的思路，对 UI 线程的 Looper 里面处理 Message 的过程进行监控。 具体做法是，在 Looper 开始处理 Message 前，在异步线程开启一个延时任务，用于后续收集信息。如果这个 Message 在指定的时间段内完成了处理，那么在这个 Message 被处理完后，就取消之前的延时任务，说明 UI 线程没有 block 。如果在指定的时间段内没有完成任务，说明 UI 线程有 block 。此时，异步线程可以执行刚才的延时任务。如果我们在这个延时任务里面打印 UI 线程的方法调用栈，就可以知道 UI 线程在做什么了。这个就是 UI 线程 block 检测的基本原理。 但是这个方案有一个缺点，就是无法处理 InputManager 的输入事件，比如 TV 端的遥控按键事件。通过对按键事件的调用方法链进行分析，发现最终每个按键事件都调用了 DecorView 类的 dispatchKeyEvent 方法，而非 Looper 的处理 Message 流程。所以 AndroidPerformanceMonitor 库是无法准确监控 TV 端应用 UI block 的情况。针对 TV 端应用按键处理，需要找到一个新的切入点，这个切入点就是刚刚的 DecorView 类的 dispatchKeyEvent 方法。 那如何介入 DecorView 类的 dispatchKeyEvent 方法呢？我们可以通过 epic 库来 hook 这个方法的调用。hook 成功后，我们可以在 DecorView 类的 dispatchKeyEvent 方法调用前后都接收到一个回调方法，在 dispatchKeyEvent 方法调用前我们可以在异步线程执行一个延时任务，在 dispatchKeyEvent 方法调用后，取消这个延时任务。如果 dispatchKeyEvent 方法耗时时间小于指定的时间阈值，延时任务在执行前被取消，可以认为没有 block ，此时移除了延时任务。如果 dispatchKeyEvent 方法耗时时间大于指定的时间阈值说明此时 UI 线程是有 block 的。此时，异步线程可以执行这个延时任务来收集必要的信息。 以上就是修改后的 UI 线程 block 的检测原理了，目前做的还比较粗糙，后续计划考虑参考 AndroidPerformanceMonitor 打印 CPU 、内存等更多的信息。 最终终端 log 打印效果如下： com.xander.performace.demo W/demo_Issue: ================================================= type: UI BLOCK msg: UI BLOCK create time: 2021-01-13 11:24:41 trace: java.lang.Thread.sleep(Thread.java:-2) java.lang.Thread.sleep(Thread.java:442) java.lang.Thread.sleep(Thread.java:358) com.xander.performance.demo.MainActivity.testANR(MainActivity.kt:49) java.lang.reflect.Method.invoke(Method.java:-2) androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397) android.view.View.performClick(View.java:7496) android.view.View.performClickInternal(View.java:7473) android.view.View.access$3600(View.java:831) android.view.View$PerformClick.run(View.java:28641) android.os.Handler.handleCallback(Handler.java:938) android.os.Handler.dispatchMessage(Handler.java:99) android.os.Looper.loop(Looper.java:236) android.app.ActivityThread.main(ActivityThread.java:7876) java.lang.reflect.Method.invoke(Method.java:-2) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967) FPS 检测的原理FPS 检测的原理，利用了 Android 的屏幕绘制原理。这里简单说下 Android 的屏幕绘制原理。 系统每隔 16 ms 就会发送一个 VSync 信号。 如果应用注册了这个 VSync 信号，就会在 VSync 信号到来的时候，收到回调，从而开始准备绘制。如果准备顺利，也就是 CPU 准备数据、GPU 栅格化等，如果这些任务在 16 ms 之内完成，那么下一个 VSync 信号到来前就可以绘制这一帧界面了。就没有掉帧，界面很流畅。如果在 16 ms 内没准备好，可能就需要更多的时间这个画面才能显示出来，在这种情况下就发生了丢帧，如果丢帧很多就卡顿了。 检测 FPS 的原理其实挺简单的，就是通过一段时间内，比如 1s，统计绘制了多少个画面，就可以计算出 FPS 了。那如何知道应用 1s 内绘制了多少个界面呢？这个就要靠 VSync 信号监听了。 在开始准备绘制前，往 UI 线程的 MessageQueue 里面放一个同步屏障，这样 UI 线程就只会处理异步消息，直到同步屏障被移除。刷新前，应用会注册一个 VSync 信号监听，当 VSync 信号到达的时候，系统会通知应用，让应用会给 UI 线程的 MessageQueue 里面放一个异步 Message 。由于之前 MessageQueue 里有了一个同步屏障，所以后续 UI 线程会优先处理这个异步 Message 。这个异步 Message 做的事情就是从 ViewRootImpl 开始我们熟悉的 measure 、layout 和 draw 。 我们可以通过 Choreographer 注册 VSync 信号监听。16ms 后，我们收到了 VSync 的信号，给 MessageQueue 里面放一个同步消息，我们不做特别处理，只是做一个计数，然后监听下一次的 VSync 信号，这样，我们就可以知道 1s 内我们监听到了多少个 VSync 信号，就可以得出帧率。 为什么监听到的 VSync 信号数量就是帧率呢？ 由于 Looper 处理 Message 是串行的，就是一次只处理一个 Message ，处理完了这个 Message 才会处理下一个 Message 。而绘制的时候，绘制任务 Message 是异步消息，会优先执行，绘制任务 Message 执行完成后，就会执行上面说的 VSync 信号计数的任务。如果忽略计数任务的耗时，那么最后统计到的 VSync 信号数量可以粗略认为是某段时间内绘制的帧数。然后就可以通过这段时间的长度和 VSync 信号数量来计算帧率了。 最终终端 log 打印效果如下： com.xander.performace.demo W/demo_FPSTool: APP FPS is: 54 Hz com.xander.performace.demo W/demo_FPSTool: APP FPS is: 60 Hz com.xander.performace.demo W/demo_FPSTool: APP FPS is: 60 Hz 线程的创建和启动监控以及线程池的创建监控线程和线程池的监控，主要是监控线程和线程池在哪里创建和执行的，如果我们可以知道这些信息，我们就可以比较清楚线程和线程池的创建和启动时机是否合理。从而得出优化方案。 一个比较容易想到的方法就是，应用代码里面的所有线程和线程池继承同一个线程基类和线程池基类。然后在构造函数和启动函数里面打印方法调用栈，这样我们就知道哪里创建和执行了线程或者线程池。 让应用所有的线程和线程池继承同一个基类，可以通过编译插件来实现，定制一个特殊的 Transform ，通过 ASM 编辑生成的字节码来改变继承关系。但是，这个方法有一定的上手难度，不太适合新手。 除了这个方法，我们还有另外一种方法，就是 hook 。通过 hook 线程或者线程池的构造方法和启动方法，我们就可以在线程或者线程池的构造方法和启动方法的前后做一些切片处理，比如打印当前方法调用栈等。这个也就是线程和线程池监控的基本原理。 线程池的监控没有太大难度，一般都是 ThreadPoolExecutor 的子类，所以我们 hook 一下 ThreadPoolExecutor 的构造方法就可以监控线程池的创建了。线程池的执行主要就是 hook 住 ThreadPoolExecutor 类的 execute 方法。 线程的创建和执行的监控方法就稍微要费些脑筋了，因为线程池里面会创建线程，所以这个线程的创建和执行应该和线程池绑定的。需要找到线程和线程池的联系，之前看到一个库，好像是通过线程和线程池的 ThreadGroup 来建立关联的，本来我也计划按照这个关系来写代码的，但是我发现，我们有的小伙伴写的线程池的 ThreadFactory 里面创建线程并没有传入ThreadGroup ，这个就尴尬了，就建立不了联系了。经过查阅相关源码发现了一个关键的类，ThreadPoolExecutor 的内部类Worker ，由于这个类是内部类，所以这个类实际的构造方法里面会传入一个外部类的实例，也就是 ThreadPoolExecutor 实例。同时， Worker 这个类还是一个 Runnable 实现，在 Worker 类通过 ThreadFactory 创建线程的时候，会把自己作为一个 Runnable 传给 Thread 所以，我们通过这个关系，就可以知道 Worker 和 Thread 的关联了。这样，我们通过 ThreadPoolExecutor 和 Worker 的关联，以及 Worker 和 Thread 的关联，就可以得到 ThreadPoolExecutor 和它创建的 Thread 的关联了。这个也就是线程和线程池的监控原理了。 最终终端 log 打印效果如下： com.xander.performace.demo W/demo_Issue: ================================================= type: THREAD msg: THREAD POOL CREATE create time: 2021-01-13 11:23:47 create trace: com.xander.performance.StackTraceUtils.list(StackTraceUtils.java:39) com.xander.performance.ThreadTool$ThreadPoolExecutorConstructorHook.afterHookedMethod(ThreadTool.java:158) de.robv.android.xposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:265) me.weishu.epic.art.entry.Entry64.onHookObject(Entry64.java:64) me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:239) java.util.concurrent.Executors.newSingleThreadExecutor(Executors.java:179) com.xander.performance.demo.MainActivity.testThreadPool(MainActivity.kt:38) java.lang.reflect.Method.invoke(Method.java:-2) androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397) android.view.View.performClick(View.java:7496) android.view.View.performClickInternal(View.java:7473) android.view.View.access$3600(View.java:831) android.view.View$PerformClick.run(View.java:28641) android.os.Handler.handleCallback(Handler.java:938) android.os.Handler.dispatchMessage(Handler.java:99) android.os.Looper.loop(Looper.java:236) android.app.ActivityThread.main(ActivityThread.java:7876) java.lang.reflect.Method.invoke(Method.java:-2) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967) IPC(进程间通讯)监控的原理进程间通讯的具体原理，也就是 Binder 机制，这里不做详细的说明，也不是这个框架库的原理。 检测进程间通讯的方法和前面检测线程的方法类似，就是找到所有的进程间通讯的方法的共同点，然后对共同点做一些修改或者说切片，让应用在进行进程间通讯的时候，打印一下调用栈，然后继续做原来的事情。就达到了 IPC 监控的目的。 那如何找到共同点，或者说切片，就是本节的重点。 进程间通讯离不开 Binder ，需要从 Binder 入手。 写一个 AIDL demo 后发现，自动生成的代码里面，接口 A 继承自 IInterface 接口，然后接口里面有个内部抽象类 Stub 类，继承自 Binder ，同时实现了接口 A 。这个 Stub 类里面还有一个内部类 Proxy ，实现了接口 A ，并持有一个 IBinder 实例。 我们在使用 AIDL 的时候，会用到 Stub 类的 asInterFace 的方法，这个方法会新建一个 Proxy 实例，并给这个 Proxy 实例传入 IBinder , 或者如果传入的 IBinder 实例如果是接口 A 的话，就强制转化为接口 A 实例。一般而言，这个 IBinder 实例是 ServiceConnection 的回调方法里面的实例，是 BinderProxy 的实例。所以 Stub 类的 asInterFace 一般会创建一个 Proxy 实例，查看这个 Proxy 接口的实现方法，发现最终都会调用 BinderProxy 的 transact 方法，所以 BinderProxy 的 transact 方法是一个很好的切入点。 本来我也是计划通过 hook 住 BinderProxy 类的 transact 方法来做 IPC 的检测的。但是 epic 库在 hook 含有 Parcel 类型参数的方法的时候，不稳定，会有异常。由于暂时还没能力解决这个异常，只能重新找切入点。最后发现 AIDL demo 生成的代码里面，除了调用了 调用 BinderProxy 的 transact 方法外，还调用了 Parcel 的 readException 方法，于是决定 hook 这个方法来切入 IPC 调用流程，从而达到 IPC 监控的目的。 最终终端 log 打印效果如下： com.xander.performace.demo W/demo_Issue: ================================================= type: IPC msg: IPC create time: 2021-01-13 11:25:04 trace: com.xander.performance.StackTraceUtils.list(StackTraceUtils.java:39) com.xander.performance.IPCTool$ParcelReadExceptionHook.beforeHookedMethod(IPCTool.java:96) de.robv.android.xposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:229) me.weishu.epic.art.entry.Entry64.onHookVoid(Entry64.java:68) me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:220) me.weishu.epic.art.entry.Entry64.voidBridge(Entry64.java:82) android.app.IActivityManager$Stub$Proxy.getRunningAppProcesses(IActivityManager.java:7285) android.app.ActivityManager.getRunningAppProcesses(ActivityManager.java:3684) com.xander.performance.demo.MainActivity.testIPC(MainActivity.kt:55) java.lang.reflect.Method.invoke(Method.java:-2) androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397) android.view.View.performClick(View.java:7496) android.view.View.performClickInternal(View.java:7473) android.view.View.access$3600(View.java:831) android.view.View$PerformClick.run(View.java:28641) android.os.Handler.handleCallback(Handler.java:938) android.os.Handler.dispatchMessage(Handler.java:99) android.os.Looper.loop(Looper.java:236) android.app.ActivityThread.main(ActivityThread.java:7876) java.lang.reflect.Method.invoke(Method.java:-2) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967) 联系我 Mail &#52;&#50;&#x30;&#54;&#x34;&#48;&#x37;&#54;&#51;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d; 微信 参考资料: epic SandHook AndroidPerformanceMonitor 面试官：如何监测应用的 FPS ？ 深入探索Android卡顿优化（下）","categories":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"Performance","slug":"Performance","permalink":"https://xanderwang.github.io/android-note/tags/Performance/"}]},{"title":"总结笔记(三) - Java 集合总结","slug":"总结笔记(三) - Java 集合总结","date":"2021-02-07T14:41:00.000Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"2021/02/07/总结笔记(三) - Java 集合总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/07/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%B8%89)%20-%20Java%20%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"[toc] Java 集合总结Java 有哪些集合，继承关系是怎么样的 平时常用的集合有哪些 Collection List 可以重复添加元素 ArrayList LinkedList Set 不能重复添加元素 HashSet 不接受 null TreeSet Queue Deque PriorityQueue 数组实现，堆 ArrayDeque 数组实现， 2 个游标 Map 以键值对的形式保存值 HashMap LinkedHashMap TreeMap Hashtable ListArrayList数组实现，初始容量为 10，不够的时候扩容，扩容就是数组在当前长度基础上增大一倍。添加数据的时候，先判断容量是否够，不够就扩容，扩容完成后再添加。 缺点: 线程不安全 LinkedList链表实现。尾插法，即新节点插入到链表尾部。 SetHashSetJava 1.8 底层基于 HashMap 实现，HashMap 的 value 都是同一个对象。 TreeSetJava 1.8 默认是 TreeMap 实现，也可以给构造方法传入一个 NavigableMap(接口) 的实现实例。 QueueDeque双端队列， PriorityQueue堆，数组实现的 ArrayDequeMapHashMap最常用的一种结构，以数组为基础，数组元素为链表的复合结构。 需要注意的是： 初始容量为 16，默认承载因子为 0.75 ，需要注意的是，在指定容量的时候，如果不是 2 的指数，会计算一个大于指定容量，但是同时又是符合要求里面最小的一个 2 的指数作为容量。 当元素个数大于或等于(当前容量 * 承载因子)，就会扩容。 Java 1.7 插入数据的时候是头插法，即新的节点在链表头部。Java 1.8 及以后是尾插法，即新的节点在链表尾部。这个修改是为了解决扩容的时候可能会发生的死循环的问题。 Java 1.8 及以后，当同一个链表元素个数大于等于 (8 - 1) 的时候，会变成红黑树来存储，目的是提高效率。红黑树的转变是先比较 key 的 hash 大小，如果相同就尝试比较 key 自身。 无论是扩容，还是转成红黑树，都是先把节点放进去后再做扩容或者转换。 hash 碰撞，是指不同的 key, key 的 hash 和数组大小再次计算后,得出的索引一致。 hash 碰撞越少，HashMap 的效率越高。1.7 和 1.8 hash 算法有区别。 LinkedHashMap基于 HashMap 实现的，同时还是一个双向循环链表(比 HashMap 的节点多了个 before 和 after 指针)，在开启排序的情况下，最近使用过的节点(put、get)会放在链表尾部。 这个特性很适合 LRU 算法的实现，大概原理就是 LinkedHashMap 开启排序，然后最近使用的元素都在链表尾部，当链表长度大于指定长度的时候，就从链表头部开始删除，因为链表头部是最近没有使用的。 Hashtablesynchroinzed 实现线程安全，效率低下。 TreeMapTreeMap 在 Java 1.8 底层实现是一个红黑树，排序的规则是比较 key 的 “大小”。并且要求 key 的类型是需要可以比较的，并且 key 值不能为 null。 和 HashMap 一样，先插入数据，然后在重排序。 碰到的常见问题线程安全问题由于以上的都不是线程安全的，所以多线程的时候容易出问题，对于安全的线程有以下的几种 List Vector 通过方法添加 synchizoned 关键字实现，效率低下。 CopyOnWriteArrayList 每次写(添加，删除，修改)的时候，都会生成一个新副本，所以频繁的写操作会消耗大量内存。 Set CopyOnWriteArraySet 类似 CopyOnWriteArrayList Map ConcurrentHashMap Java 1.7 是通过分段锁实现，Java 1.8 是 CAS 和 synchroinzed 实现 ConcurrentHashMap分段锁来实现，分段锁可以提高效率，是因为如果不同线程的读写发生在不同的段上，实际上是没有锁竞争的，也就是没有线程被阻塞，所以效率高。 Java 1.7 及以前实现原理ConcurrentHashMap 有一个 segments 数组，这个数组元素的类型是 Segment，它继承自 ReentrantLock ，也就是说 Segment 是一个锁。 ConcurrentHashMap 插入或者修改数据的时候，会先找到是哪一个 segment , 然后在这个 segment 上面插入或者修改数据，而 segment 插入或者修改数据的时候，会先尝试获取锁，如果获取失败，说明有锁竞争，然后先尝试自旋，自旋超过次后，就开始阻塞线程。因此是线程安全的。 另外需要注意的是获取数据的时候没有加锁，因为是 volatile 变量，可以拿到最新的数据，但是呢， Java 1.8 及以后实现原理类似 HashMap ,放弃了分段锁，在插入或者修改数据的时候利用 cas 和 synchionzed 来保证线程安全，大概的原理就是先利用 cas 来设置，设置失败的时候说明有线程竞争，这个时候就用 synchionzed 来加锁，保证线程安全。 Java 1.8 之后，为何放弃了分段锁分段后，数据不连续，碎片较多，内存浪费严重，扩容等操作耗费大量的时间。 Java 1.8 是用的 synchornized + HashMap 来做的， synchornized jvm 层做了优化，同时 HashMap 也做了红黑树的优化，所以效率方面有保障。 主要方法总结List 接口- add(E):boolean - add(int, E):boolean - remove(int):E - remove(E):boolean - size():int Stack 类继承自 Vector , Vector 是一个同步安全的 List - push(E):E 入栈 - pop():E 出栈 - peek():E 查看顶部第一个元素 - search(Object):int - empty() 是否是空的 Set 接口- add(E):boolean - contains(Object):boolean - remove(Object):boolean - size():int Queue- add 添加元素，返回添加结果，如果不能添加就抛出异常 - remove 删除队列头，空队列异常 - element 返回队列头，空队列异常 - offer 添加元素，返回添加结果 - poll 返回并删除队列头，空队列的话返回 null - peek 返回队列头，空队列的话返回 null Map 接口- put(K, V):V - remove(Object):V - containsKey(Object):boolean - containsValue(Object):boolean - size():int ArrayMap 和 HashMapArrayMap 有缓存， HashMap 没有 内存小 深度解读ArrayMap优势与缺陷 SparseArray 和 ArrayList","categories":[{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"集合","slug":"集合","permalink":"https://xanderwang.github.io/android-note/tags/%E9%9B%86%E5%90%88/"}]},{"title":"总结笔记(二) - Java 反射和注解总结","slug":"总结笔记(二) - Java 反射和注解总结","date":"2021-02-07T14:41:00.000Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"2021/02/07/总结笔记(二) - Java 反射和注解总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/07/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20-%20Java%20%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/","excerpt":"","text":"反射总结什么是反射反射是 Java 语言的一个特性，就是在程序运行状态中，对于任何一个类，都可以通过反射知道这个类所有的方法和属性。对于任何一个实例，都可以调用这个实例的任何方法和属性。这个在运行时动态获取类或者实例的属性和方法，动态调用属性和方法的特性就叫反射。 反射有什么用从特性可以看出，在运行时可以动态调整属性的值和调用代码，可以让程序更灵活。主要用于以下几点 动态创建实例( class.newInstance 方法 ) 调用某个方法( method.invoke 方法 ) 修改或者获取某个字段的值 反射的常用方法介绍Class 常用方法介绍getDeclaringClass 一般针对内部类，如 B 是 A 的内部类，在 B 的 class 上调用这个方法，返回的是 A getDeclaredClasses 获取当前类声明的内部类 getClasses 包含当前类的父类和声明的 public 的内部类 newInstance 创建一个类的实例 forName 获取一个类，如果类没有加载会加载 getConstructor 系列方法，可以获取构造方法类实例，然后调用实例的 newInstance 方法可以获得一个实例 Method 常用方法介绍getMethod 获取 public 的方法，包括继承的 getDeclaredMethod 该类里面的定义的方法，包括私有的和实现的接口的方法。 invoke 该方法可以调用某个实例的某个方法。第一个参数为 null 时表示调用静态方法，第一个参数传入某个实例的时候，表示调用实例的某个方法。 Filed 常用方法介绍getField 获取字段 getDeclaredField 常用的场景动态配置可以通过 Class.forName 方法加载指定的配置类，然后读取配置，以达到动态配置的效果。 动态代理动态代理底层用到了反射。 hook 框架动态生成实例，修改字段值、调用非 public 方法 参考资料： 学习java应该如何理解反射？ 注解总结什么是注解注解是 JDK 1.5 引入的一个特性，用来给 Java 代码提供元数据。注解本身不直接影响代码的执行。 如何理解呢？注解是 Java 的一个特性，元数据可以理解为给编译器或者 jvm 看的++注释++，不直接影响程序的运行。但是可以在运行时通过读取注解做一些事情。可以把元数据理解为额外的一些可用可不用的额外信息。 注解定义和定义接口类似，只不过关键字是 @interface。下面一段代码演示了如何定义个注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface TestAnnotation &#123; int id(); String msg(); &#125; 注解的应用场景 提供信息给编译器 这个接触的不多 编译阶段的处理 比如生产文档，这个有时候会用 运行时的处理 这个相对用的多，就是说运行时读取注解的值，来做一些事情，比如 Retrofit 框架库，就用到了注解。具体的原理分析在后续笔记记录。 参考资料： java注解-最通俗易懂的讲解","categories":[{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"反射","slug":"反射","permalink":"https://xanderwang.github.io/android-note/tags/%E5%8F%8D%E5%B0%84/"},{"name":"注解","slug":"注解","permalink":"https://xanderwang.github.io/android-note/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"总结笔记(一) - 泛型总结","slug":"总结笔记(一) - 泛型总结","date":"2020-07-23T04:44:44.000Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"2020/07/23/总结笔记(一) - 泛型总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2020/07/23/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%B8%80)%20-%20%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"泛型总结泛型是什么？一句话说就是类型参数化。什么意思呢？参数化的意思就是我们在定义的时候不知道具体的值，我们在到我们实际运行的时候才知道具体的值。类型参数化就是具体类型在定义的时候不知道，在实际运行的时候是确定的某一个类型。 Java 是如何实现泛型的？泛型是很多高级语言都有的特性。根据定义，泛型在运行时表示同一个类型，我们比较容易想到 List&lt;A&gt; 和 List&lt;B&gt; 用 2 个不同的 Class 表示，这个是可行的，但是 Java 由于需要兼容支持旧的代码，而且在推出泛型前就提供了容器类，这种方式(List&lt;A&gt; 和 List&lt;B&gt; 用 2 个不同的 Class)无法兼容以前的老代码，所以这个实现方法不适用。所以 Java 大佬们想了另外一种方式来实现泛型,这种方式就是类型擦除。 什么是泛型的类型擦除呢？类型擦除就是在实际生成字节码的时候，编译器源码里面定义的 List&lt;A&gt; 变成了 List&lt;Object&gt;,源码里面定义的 A Class 被擦除了，变成了 Object，同时在使用的时候，会强制类型转换，把取出来的 object 转成 A 的实例去使用。这就是类型擦除。 初步看，泛型擦除好像是没什么大的问题，但是仔细想想，在强制类型转换的时候，由于会丢掉类型的一些信息，会导致一些不符合预期的事情。比如有个基类 A，和它的两个子类 B 和 C ，然后我们有下面的一段代码。 List&lt;A&gt; listA = new ArrayList&lt;A&gt;(); listA.add(new B()); // 错误的， 第二行代码是不符合预期的，因为 listA 里面期望放的是 A 而不是 B。 但是这个好像不太符合预期，我们有时候希望子类是可以放进容器里面的。但是如果支持这个操作的话，会发生什么呢？取出来来的是 B 还是 C ？如果不能明确，那么就没有实现“泛型”。 为了解决这个问题， Java 大佬们想了个方法，提出了一些通配符来解决这些问题。 泛型的通配符 ?、extends 和 super在理解通配符之前，我们需要知道的是，通配符的发明是为了解决什么问题？至少要解决的一个问题是：容器里面放进去的是什么，取出来的就是什么。 这个问题，其实分两步，放进去，是说放进去同一种类型的东西。取出来，是说取出同一种类型的东西。或者说，用到通配符的地方应该是在不同的地方，一个地方把数据写到容器，另外一个地方把数据从容器拿出来，如果实在同一个代码块里写入和读取数据到同一个容器，应该是知道具体类型的，是不需要用到通配符的。 ? 通配符? 通配符称为无限通配符，表示不确定或者不关心类型。 extends 通配符一般称为上界通配符，表示的意思是：取值范围为 (某个类的子类, 某个类]。再想想我们之前说的，通配符要解决的问题？放进去的是什么，取出来的就应该是什么。放数据和取数据应用在不同的场景。 通过上面的表述，容易推断出来 &lt;? extends E&gt; 的集合只能往外拿数据，因为取出来的一定是 E ，但是放进去的不知道是什么，可能是 E ，也可能是 E 的子类，如果允许往集合里面放东西，就不能保证放进去的是什么，拿出来的就是什么了。因为只能保证拿出来的是 E 。 super 通配符一般称为下界通配符，表示的意思是：取值范围为 [某个类，这个类的父类)。结合上面小节的解释，可以推断出 &lt;? super S&gt; 的集合只能往里面放数据，而不能从里面拿东西，为什么呢？因为 &lt;? extends E&gt; 解决的就是拿出来的问题啊，所以这个解决的就是放进去的问题啊，囧。里面放的是下限或者下限的子类。 小结通配符与一个规则， PE-CS。 PE 是说，如果 T 表示的是一个生产者，应该用 extends 通配符。因为生产者有上限，比如生产笔的公司，上限就是能生产笔，但是不能生产布。 CS 是说，如果某个集合表示一个消费者，应该用 super 通配符。因为消费者是有下限的，好比去买笔，购物车里面可以放铅笔、钢笔或者毛笔。这些下限就是笔，就是说都是笔。 同时作为生产者和消费者的情况不存在，因为你可以指定具体的泛型。 参考资料： 深入理解 Java 泛型","categories":[{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"泛型","slug":"泛型","permalink":"https://xanderwang.github.io/android-note/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"Android 性能优化总结","slug":"Android 性能优化总结","date":"2020-03-08T12:01:01.000Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"2020/03/08/Android 性能优化总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2020/03/08/Android%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/","excerpt":"","text":"性能优化总结性能的优化是一个老生常谈的点，也是一个比较重要的点。现在对工作中的优化点做一个总结。 优化的方向，即那些点是需要优化的在平时的优化过程中我们需要从哪几个点来优化呢？其实我们平时自己一定也用过软件，在使用软件的过程中有没有什么想吐槽的呢？“太卡了吧！”、”图片怎么还没加载出来？”、”怎么刚进去就卡了。”等等，是不是有这样的想法，这些想法其实包含了我们今天要说的内容，就是从哪些方面来优化我们的 APP ，我总结了以下几点。 启动速度 操作流畅度 内存的管理和使用 图片的加载 当然，需要优化的不仅仅是这几个方面，我们暂时先就这几个方面来谈谈优化吧 启动速度启动速度是一个很关键的点，相信平时大家在使用软件的时候，如果点了应用的图标，结果很久才能进入主界面，很久才能操作。那么这个应用大概率会被卸载。 那我们如何优化我们的 APP 的启动速度呢？ 首先，第一步我们要知道我们的应用启动花的时间， 操作流畅度内存的管理和使用图片的加载","categories":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"Performance","slug":"Performance","permalink":"https://xanderwang.github.io/android-note/tags/Performance/"},{"name":"优化","slug":"优化","permalink":"https://xanderwang.github.io/android-note/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"Android 学习大纲总结","slug":"Android 学习大纲总结","date":"2020-02-16T04:16:44.000Z","updated":"2021-02-26T06:39:39.531Z","comments":true,"path":"2020/02/16/Android 学习大纲总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2020/02/16/Android%20%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2%E6%80%BB%E7%BB%93/","excerpt":"","text":"我的 Android 学习笔记 Java 基础 基础类型 循环控制 常见集合 数据结构 数组 队列 链表 栈 字典 树 基础控件 五种 Layout ImageView ListView RecyclerView Dialog 自定义控件 流程 属性自定义 Canvas 事件下发 四大组件 Activity Service Provider Broadcast 多媒体 其他 Jetpack 动画 Handler AsyncTask Manifast 跨进程通信 保活 传感器 震动 步数 指南针 FrameWork AMS PMS WMS 常用框架 图片 网络 异步 组件化 插件化 算法 八种排序算法 书籍推荐 我的 Android 学习笔记Java 基础基础类型Java 八大基本数据类型 循环控制Java控制语句 常见集合java常用集合类及其区别、源码分析（一） JAVA集合框架中的常用集合及其特点、适用场景、实现原理简介 数据结构数组Java数组的定义和使用 Java 数组基础 队列Java 集合深入理解（9）：Queue 队列 java队列——queue详细分析 链表【数据结构】链表的原理及java实现 Java链表实现以及链表倒置 栈Java 数据结构之 Stack(栈) java数据结构与算法之栈（Stack）设计与实现 字典Java map 详解 - 用法、遍历、排序、常用API等 Java Map集合的详解 树K：树、二叉树与森林之间的转换及其相关代码实现 基础控件五种 LayoutImageViewListViewRecyclerViewDialog自定义控件流程属性自定义Canvas事件下发四大组件ActivityServiceProviderBroadcast多媒体其他Jetpack动画HandlerAsyncTaskManifast跨进程通信保活传感器震动步数指南针FrameWorkAMSPMSWMS常用框架图片网络异步组件化插件化算法八种排序算法书籍推荐","categories":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/tags/Java/"}]}],"categories":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"},{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xanderwang.github.io/android-note/tags/hexo/"},{"name":"Github Action","slug":"Github-Action","permalink":"https://xanderwang.github.io/android-note/tags/Github-Action/"},{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://xanderwang.github.io/android-note/tags/GitHub-Page/"},{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"Performance","slug":"Performance","permalink":"https://xanderwang.github.io/android-note/tags/Performance/"},{"name":"集合","slug":"集合","permalink":"https://xanderwang.github.io/android-note/tags/%E9%9B%86%E5%90%88/"},{"name":"反射","slug":"反射","permalink":"https://xanderwang.github.io/android-note/tags/%E5%8F%8D%E5%B0%84/"},{"name":"注解","slug":"注解","permalink":"https://xanderwang.github.io/android-note/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"泛型","slug":"泛型","permalink":"https://xanderwang.github.io/android-note/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"优化","slug":"优化","permalink":"https://xanderwang.github.io/android-note/tags/%E4%BC%98%E5%8C%96/"},{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/tags/Java/"}]}