<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用 GitHub 搭建自己的个人博客</title>
      <link href="/android-note/2021/02/25/%E5%88%A9%E7%94%A8%20GitHub%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/android-note/2021/02/25/%E5%88%A9%E7%94%A8%20GitHub%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>先看下预览图吧。</p><p><img src="https://img.imgdb.cn/item/6037cadc5f4313ce25858739.png" class="lazyload placeholder" data-srcset="https://img.imgdb.cn/item/6037cadc5f4313ce25858739.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="预览图"></p><p>先说下方案:</p><blockquote><p> GitHub Page + GitHub Action + hexo &amp; 配套主题 </p></blockquote><h1 id="GitHub-Page"><a href="#GitHub-Page" class="headerlink" title="GitHub Page"></a>GitHub Page</h1><p>这个都不陌生吧，注册 GitHub 账号后，可以帮你托管你的 <code>repository</code> 下的静态网页，比如我有个 <code>repository</code> 叫  <code>android-note</code> ，我的 github 账号叫 <code>xanderwang</code> ，那么我的 android-note 托管后，访问地址就是：</p><blockquote><p><a href="https://xander.github.io/android-note">https://xander.github.io/android-note</a></p></blockquote><p>托管后，如果我每次写了新的文章后，我把最新的静态 blog 上传上来，那么就可以更新自己的博客。</p><p>如果每次都可以自动编译和上传 blog 静态网页，那就很省事了。事实上，这个是可以做到的，具体细节后面再说。我们先看看如何托管我们的 <code>repository</code> 到 GitHub Page 。</p><p>最开始接触到 GitHub Page 的时候，看文章都是说需要新建一个和自己用户名同名的 <code>repository</code> ，然后往这个 <code>repository</code> 根目录里面上传静态 blog 网页，然后托管。</p><p>后来我发现不是这样，至少目前不是这样，我发现任意的 <code>repository</code> 都可以托管，只需要做一些特别的设置，如何设置呢？</p><p>找到你的 <code>repository</code> ，然后</p><blockquote><p>settings -&gt; GitHub Pages -&gt; Source -&gt; 选择分支和静态博客的根目录</p></blockquote><p>到这里 GitHub 托管就设置好了。按照之前的规则你就可以访问你托管 blog 了。</p><h1 id="GitHub-Action"><a href="#GitHub-Action" class="headerlink" title="GitHub Action"></a>GitHub Action</h1><p>刚刚说了，如果有个自动编译和上传 blog 的工具或者平台，每次我们写好 blog 后，自动帮我们编译上传好，那我们就可以省很多事。GitHub Action 正好可以做这个的，而且可以和 GitHub 无缝对接。那如何使用呢？</p><p>很简单，只需要在你的 <code>repository</code> 里面新建 <code>.github</code> 文件夹，然后在里面新建 <code>.workflows</code> 文件夹，然后在里面新建 <code>build.yml</code> 文件(build 可以换成任意你喜欢的)，然后 GitHub Action 功能就开通了。这个时候， <code>repository</code> 下的目录结构大概是</p><pre><code>.├── .github│   └── workflows│       └── build.yml</code></pre><p>现在介绍下如何配置 build.yml 文件</p><pre><code class="yml">name: Xander&#39;s Blog Task# 在push **.md **.yml **.yaml **.sh 文件后执行任务on: #配置任务执行时机  # Trigger the workflow on push or pull request,  # but only for the master branch  push:    # branches:        #   - master    paths:      - &#39;**.md&#39;      - &#39;**.yml&#39;      - &#39;**.yaml&#39;      - &#39;**.sh&#39;jobs: # 配置具体任务  build:    # runs-on: macOS-latest    runs-on: ubuntu-latest    steps:    # 引用外部 Action, 拉取代码仓库到虚拟机工作目录    - name: chekout code      uses: actions/checkout@v1    # 执行 .sh 脚本文件，很多的任务可以在这个脚本里面执行    - name: build note      run: sh ./build.sh      # 这里是一些额外的操作, 通常不需要. 这里是为了把编译好的静态 blog 文件 push 到 GitHub 仓库    - name: commit change      run: |        git config --local user.email &quot;420640763@qq.com&quot;        git config --local user.name &quot;$GITHUB_ACTOR&quot;        echo &quot;---------- git config --list&quot;        git config --list        echo &quot;---------- git status&quot;        git status        echo &quot;---------- git add ./&quot;        git add ./        echo &quot;---------- git commit&quot;        git commit -m &quot;auto build task&quot;        echo &quot;---------- git status&quot;        git status    # 这里引用其他的 Action ，上传 commit 到自己的 repository     - name: push changes      uses: ad-m/github-push-action@master      with:        github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; </code></pre><p>上面列出了主要的步骤和解释了，具体可以参考<a href="https://github.com/XanderWang/android-note">我的 repository</a> </p><p>到这里自动编译和发布的工作就说完了，现在我们还缺什么？</p><h1 id="hexo-amp-配套主题"><a href="#hexo-amp-配套主题" class="headerlink" title="hexo &amp; 配套主题"></a>hexo &amp; 配套主题</h1><p>前面说了托管和自动编译和发布，现在我们就差一个个性化的静态 blog 模板了，这里我选择的是 hexo &amp; 配套主题。</p><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>这个是一个静态的博客构建软件，配合网络上的主题，可以比较方便构建出自己的博客，同时有大量的精美主题可以选择。</p><p>如何安装就不具体说了，不是很难，官网有很详细的教程。</p><p><a href="https://hexo.io/zh-cn/index.html">点我直达 hexo 官网</a></p><h2 id="hexo-配套主题"><a href="#hexo-配套主题" class="headerlink" title="hexo 配套主题"></a>hexo 配套主题</h2><p>主题的话，一般可以在 GitHub 上面找，我暂时用的 <a href="https://volantis.js.org/">volantis</a>，可以去官网看下这个主题的具体介绍和相关配置。</p><p>这里说下可能遇到的坑的，</p><p>这里说下 _config.yml</p><pre><code class="yml">...# URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: https://xanderwang.github.io/android-noteroot: /android-note/# 需要注意这里的配置，注意 url 和 root 的配置，如果不是用的GitHub 同名 repository 托管的，都需要配置# Directorypublic_dir: docs      # 公共文件夹，这个文件夹用于存放生成的站点文件。# public_dir 目录就是 hexo 编译后存放静态 html 的目录，在托管 GitHub Page 的时候注意选择这个目录。...</code></pre><p>其他的配置就是主题配置了，这个建议按照注意的 repository 或者主题的 demo 去配置，每个主题都是不一样的，只能靠自己的折腾了。 </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Github Action </tag>
            
            <tag> GitHub Page </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写了个 Android 性能检测的库，还有人看性能相关的么</title>
      <link href="/android-note/2021/02/24/%E5%86%99%E4%BA%86%E4%B8%AA%20Android%20%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E7%9A%84%E5%BA%93%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BA%BA%E7%9C%8B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B9%88/"/>
      <url>/android-note/2021/02/24/%E5%86%99%E4%BA%86%E4%B8%AA%20Android%20%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E7%9A%84%E5%BA%93%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BA%BA%E7%9C%8B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>由于本人工作需要，需要解决一些性能问题，虽然有 <code>Profiler</code> 、<code>Systrace </code> 等工具，但是无法实时监控，多少有些不方便，于是计划写一个能实时监控性能的小工具。经过学习大佬们的文章，最终完成了这个开源的性能实时检测库。初步能达到预期效果，这里做个记录，算是小结了。</p><p>开源库的<a href="https://github.com/XanderWang/performance">地址</a>是:</p><blockquote><p><a href="https://github.com/XanderWang/performance">https://github.com/XanderWang/performance</a></p></blockquote><p>幸苦各位能给个小小的 star 鼓励下。</p><p>这个性能检测库，可以检测以下问题：</p><ul><li><input checked="" disabled="" type="checkbox"> UI 线程 block 检测。</li><li><input checked="" disabled="" type="checkbox"> App 的 FPS 检测。</li><li><input checked="" disabled="" type="checkbox"> 线程的创建和启动监控以及线程池的创建监控。</li><li><input checked="" disabled="" type="checkbox"> IPC (进程间通讯)监控。</li></ul><p>同时还实现了以下功能：</p><ul><li><input checked="" disabled="" type="checkbox"> 实时通过 logcat 打印检测到的问题。</li><li><input checked="" disabled="" type="checkbox"> 保存检测到的信息到文件。</li><li><input checked="" disabled="" type="checkbox"> 提供上报信息文件接口。</li></ul><h1 id="接入指南"><a href="#接入指南" class="headerlink" title="接入指南"></a>接入指南</h1><p>1 在 <code>APP</code> 工程目录下面的 <code>build.gradle</code> 添加如下内容。</p><pre><code class="groovy">dependencies &#123;  // 必选  debugImplementation &quot;com.xander.performance:perf:0.1.12&quot;  releaseImplementation &quot;com.xander.performance:perf-noop:0.1.12&quot;    // hook 方案封装，必须添加  debugImplementation &quot;com.xander.performance:perf-hook:0.1.12&quot;    // 以下是 hook 方案选择一个就好了。如果运行报错，就换另外一个，如果还是报错，就提个 issue  // SandHook 方案，推荐添加。如果运行报错，可以替换为 epic 库。  debugImplementation &quot;com.xander.performance:perf-hook-sandhook:0.1.12&quot;  // epic 方法。如果运行报错，可以替换为 SandHook。  // debugImplementation &quot;com.xander.performance:perf-hook-epic:0.1.12&quot;&#125;</code></pre><p>2 <code>APP</code> 工程的 <code>Application</code> 类新增类似如下初始化代码。</p><p>Java 初始化示例</p><pre><code class="java">  private void initPERF(final Context context) &#123;    final PERF.LogFileUploader logFileUploader = new PERF.LogFileUploader() &#123;      @Override      public boolean upload(File logFile) &#123;        return false;      &#125;    &#125;;    PERF.init(new PERF.Builder()        .checkUI(true, 100) // 检查 ui lock        .checkIPC(true) // 检查 ipc 调用        .checkFps(true, 1000) // 检查 fps        .checkThread(true) // 检查线程和线程池        .globalTag(&quot;test_perf&quot;) // 全局 logcat tag ,方便过滤        .cacheDirSupplier(new PERF.IssueSupplier&lt;File&gt;() &#123;          @Override          public File get() &#123;            // issue 文件保存目录            return context.getCacheDir();          &#125;        &#125;)        .maxCacheSizeSupplier(new PERF.IssueSupplier&lt;Integer&gt;() &#123;          @Override          public Integer get() &#123;            // issue 文件最大占用存储空间            return 10 * 1024 * 1024;          &#125;        &#125;)        .uploaderSupplier(new PERF.IssueSupplier&lt;PERF.LogFileUploader&gt;() &#123;          @Override          public PERF.LogFileUploader get() &#123;            // issue 文件上传接口            return logFileUploader;          &#125;        &#125;)        .build());  &#125;</code></pre><p>kotlin 示例</p><pre><code class="kotlin">  private fun doUpload(log: File): Boolean &#123;    return false  &#125;  private fun initPERF(context: Context) &#123;    PERF.init(PERF.Builder()        .checkUI(true, 100)// 检查 ui lock        .checkIPC(true) // 检查 ipc 调用        .checkFps(true, 1000) // 检查 fps        .checkThread(true)// 检查线程和线程池        .globalTag(&quot;test_perf&quot;)// 全局 logcat tag ,方便过滤        .cacheDirSupplier &#123; context.cacheDir &#125; // issue 文件保存目录        .maxCacheSizeSupplier &#123; 10 * 1024 * 1024 &#125; // issue 文件最大占用存储空间        .uploaderSupplier &#123; // issue 文件的上传接口实现          PERF.LogFileUploader &#123; logFile -&gt; doUpload(logFile) &#125;        &#125;        .build()    )  &#125;</code></pre><h1 id="主要更新记录"><a href="#主要更新记录" class="headerlink" title="主要更新记录"></a>主要更新记录</h1><ul><li>0.1.12 线程创建的监控，加入 thread name 信息收集。同时接入 startup 库做必要的初始化，以及调整 mulit dex 的时候，配置文件找不到的问题。</li><li>0.1.11 优化 hook 方案的封装，通过 SandHook ,IPC 的监控可以按照耗时时间来检测。</li><li>0.1.10 FPS 的检测时间间隔从默认 2s 调整为 1s，同时支持自定义时间间隔。</li><li>0.1.9  优化线程池创建的监控。</li><li>0.1.8  初版发布，完成基本的功能。</li></ul><p>不建议直接在线上使用这个库，在编写这个库，测试 hook 的时候，在不同的机器和 <code>rom</code> 上，会有不同的问题，这里建议先只在线下自测使用这个检测库。</p><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><h2 id="UI-线程-block-检测原理"><a href="#UI-线程-block-检测原理" class="headerlink" title="UI 线程 block 检测原理"></a>UI 线程 block 检测原理</h2><p>主要参考了 <code>AndroidPerformanceMonitor</code> 库的思路，对 <code>UI</code> 线程的 <code>Looper</code> 里面处理 <code>Message</code> 的过程进行监控。</p><p>具体做法是，在 <code>Looper</code> 开始处理 <code>Message</code> 前，在异步线程开启一个延时任务，用于后续收集信息。如果这个 <code>Message</code> 在指定的时间段内完成了处理，那么在这个 <code>Message</code> 被处理完后，就取消之前的延时任务，说明 <code>UI</code> 线程没有 block 。如果在指定的时间段内没有完成任务，说明 <code>UI</code> 线程有 block 。此时，异步线程可以执行刚才的延时任务。如果我们在这个延时任务里面打印 <code>UI</code> 线程的方法调用栈，就可以知道 <code>UI</code> 线程在做什么了。这个就是 <code>UI</code>  线程 block 检测的基本原理。</p><p>但是这个方案有一个缺点，就是无法处理 <code>InputManager</code> 的输入事件，比如 <code>TV</code> 端的遥控按键事件。通过对按键事件的调用方法链进行分析，发现最终每个按键事件都调用了 <code>DecorView</code> 类的 <code>dispatchKeyEvent</code> 方法，而非 <code>Looper</code> 的处理 <code>Message</code> 流程。所以 <code>AndroidPerformanceMonitor</code> 库是无法准确监控 TV 端应用 <code>UI</code>  block 的情况。针对 <code>TV</code> 端应用按键处理，需要找到一个新的切入点，这个切入点就是刚刚的 <code>DecorView</code> 类的 <code>dispatchKeyEvent</code> 方法。</p><p>那如何介入 <code>DecorView</code> 类的 <code>dispatchKeyEvent</code> 方法呢？我们可以通过 <code>epic</code> 库来 <code>hook</code> 这个方法的调用。<code>hook</code> 成功后，我们可以在 <code>DecorView</code> 类的 <code>dispatchKeyEvent</code> 方法调用前后都接收到一个回调方法，在 <code>dispatchKeyEvent</code> 方法调用前我们可以在异步线程执行一个延时任务，在 <code>dispatchKeyEvent</code> 方法调用后，取消这个延时任务。如果 <code>dispatchKeyEvent</code> 方法耗时时间小于指定的时间阈值，延时任务在执行前被取消，可以认为没有 block ，此时移除了延时任务。如果 <code>dispatchKeyEvent</code> 方法耗时时间大于指定的时间阈值说明此时 <code>UI</code>  线程是有 block 的。此时，异步线程可以执行这个延时任务来收集必要的信息。</p><p>以上就是修改后的 <code>UI</code> 线程 block 的检测原理了，目前做的还比较粗糙，后续计划考虑参考 <code>AndroidPerformanceMonitor</code> 打印 CPU 、内存等更多的信息。</p><p>最终终端 log 打印效果如下：</p><pre><code>com.xander.performace.demo W/demo_Issue: =================================================    type: UI BLOCK    msg: UI BLOCK    create time: 2021-01-13 11:24:41    trace:        java.lang.Thread.sleep(Thread.java:-2)        java.lang.Thread.sleep(Thread.java:442)        java.lang.Thread.sleep(Thread.java:358)        com.xander.performance.demo.MainActivity.testANR(MainActivity.kt:49)        java.lang.reflect.Method.invoke(Method.java:-2)        androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397)        android.view.View.performClick(View.java:7496)        android.view.View.performClickInternal(View.java:7473)        android.view.View.access$3600(View.java:831)        android.view.View$PerformClick.run(View.java:28641)        android.os.Handler.handleCallback(Handler.java:938)        android.os.Handler.dispatchMessage(Handler.java:99)        android.os.Looper.loop(Looper.java:236)        android.app.ActivityThread.main(ActivityThread.java:7876)        java.lang.reflect.Method.invoke(Method.java:-2)        com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)        com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)</code></pre><h2 id="FPS-检测的原理"><a href="#FPS-检测的原理" class="headerlink" title="FPS 检测的原理"></a>FPS 检测的原理</h2><p>FPS 检测的原理，利用了 Android 的屏幕绘制原理。这里简单说下 Android 的屏幕绘制原理。</p><p>系统每隔 16 ms 就会发送一个 <code>VSync</code> 信号。 如果应用注册了这个 <code>VSync</code> 信号，就会在 <code>VSync </code> 信号到来的时候，收到回调，从而开始准备绘制。如果准备顺利，也就是 <code>CPU</code> 准备数据、<code>GPU</code> 栅格化等，如果这些任务在 16 ms 之内完成，那么下一个 <code>VSync</code> 信号到来前就可以绘制这一帧界面了。就没有掉帧，界面很流畅。如果在 16 ms 内没准备好，可能就需要更多的时间这个画面才能显示出来，在这种情况下就发生了丢帧，如果丢帧很多就卡顿了。</p><p>检测 FPS 的原理其实挺简单的，就是通过一段时间内，比如 1s，统计绘制了多少个画面，就可以计算出 FPS 了。那如何知道应用 1s 内绘制了多少个界面呢？这个就要靠 <code>VSync</code> 信号监听了。</p><p>在开始准备绘制前，往 <code>UI</code> 线程的 <code>MessageQueue</code> 里面放一个<strong>同步屏障</strong>，这样 <code>UI</code> 线程就只会处理异步消息，直到<strong>同步屏障</strong>被移除。刷新前，应用会注册一个 <code>VSync</code> 信号监听，当 <code>VSync</code> 信号到达的时候，系统会通知应用，让应用会给 <code>UI</code> 线程的 <code>MessageQueue</code> 里面放一个<strong>异步 <code>Message</code> <strong>。由于之前 <code>MessageQueue</code> 里有了一个</strong>同步屏障</strong>，所以后续 <code>UI</code> 线程会优先处理这个<strong>异步 <code>Message</code></strong> 。这个<strong>异步 <code>Message</code></strong> 做的事情就是从  <code>ViewRootImpl</code> 开始我们熟悉的 <code>measure</code> 、<code>layout</code> 和 <code>draw</code> 。</p><p>我们可以通过 <code>Choreographer</code> 注册 <code>VSync</code> 信号监听。16ms 后，我们收到了 <code>VSync</code> 的信号，给 <code>MessageQueue</code> 里面放一个<strong>同步消息</strong>，我们不做特别处理，只是做一个计数，然后监听下一次的 <code>VSync</code> 信号，这样，我们就可以知道 1s 内我们监听到了多少个 <code>VSync</code> 信号，就可以得出帧率。</p><p>为什么监听到的 <code>VSync</code> 信号数量就是帧率呢？</p><p>由于 <code>Looper</code> 处理 <code>Message</code> 是串行的，就是一次只处理一个 <code>Message</code> ，处理完了这个 <code>Message</code> 才会处理下一个 <code>Message</code> 。而绘制的时候，绘制任务 <code>Message</code> 是异步消息，会优先执行，绘制任务 <code>Message</code> 执行完成后，就会执行上面说的 <code>VSync</code> 信号计数的任务。如果忽略计数任务的耗时，那么最后统计到的 <code>VSync</code> 信号数量可以粗略认为是某段时间内绘制的帧数。然后就可以通过这段时间的长度和 <code>VSync</code> 信号数量来计算帧率了。</p><p>最终终端 log 打印效果如下：</p><pre><code>com.xander.performace.demo W/demo_FPSTool: APP FPS is: 54 Hzcom.xander.performace.demo W/demo_FPSTool: APP FPS is: 60 Hzcom.xander.performace.demo W/demo_FPSTool: APP FPS is: 60 Hz</code></pre><h2 id="线程的创建和启动监控以及线程池的创建监控"><a href="#线程的创建和启动监控以及线程池的创建监控" class="headerlink" title="线程的创建和启动监控以及线程池的创建监控"></a>线程的创建和启动监控以及线程池的创建监控</h2><p>线程和线程池的监控，主要是监控线程和线程池在哪里创建和执行的，如果我们可以知道这些信息，我们就可以比较清楚线程和线程池的创建和启动时机是否合理。从而得出优化方案。</p><p>一个比较容易想到的方法就是，应用代码里面的所有线程和线程池继承同一个线程基类和线程池基类。然后在构造函数和启动函数里面打印方法调用栈，这样我们就知道哪里创建和执行了线程或者线程池。</p><p>让应用所有的线程和线程池继承同一个基类，可以通过编译插件来实现，定制一个特殊的 <code>Transform</code> ，通过 <code>ASM</code> 编辑生成的字节码来改变继承关系。但是，这个方法有一定的上手难度，不太适合新手。</p><p>除了这个方法，我们还有另外一种方法，就是 <code>hook</code> 。通过 <code>hook</code> 线程或者线程池的构造方法和启动方法，我们就可以在线程或者线程池的构造方法和启动方法的前后做一些切片处理，比如打印当前方法调用栈等。这个也就是线程和线程池监控的基本原理。</p><p>线程池的监控没有太大难度，一般都是 <code>ThreadPoolExecutor</code> 的子类，所以我们 <code>hook</code> 一下 <code>ThreadPoolExecutor</code> 的构造方法就可以监控线程池的创建了。线程池的执行主要就是 <code>hook</code> 住 <code>ThreadPoolExecutor</code> 类的 <code>execute</code> 方法。</p><p>线程的创建和执行的监控方法就稍微要费些脑筋了，因为线程池里面会创建线程，所以这个线程的创建和执行应该和线程池绑定的。需要找到线程和线程池的联系，之前看到一个库，好像是通过线程和线程池的 <code>ThreadGroup</code> 来建立关联的，本来我也计划按照这个关系来写代码的，但是我发现，我们有的小伙伴写的线程池的 <code>ThreadFactory</code> 里面创建线程并没有传入<code>ThreadGroup</code> ，这个就尴尬了，就建立不了联系了。经过查阅相关源码发现了一个关键的类，<code>ThreadPoolExecutor</code> 的内部类<code>Worker</code> ，由于这个类是内部类，所以这个类实际的构造方法里面会传入一个外部类的实例，也就是 <code>ThreadPoolExecutor</code> 实例。同时， <code>Worker</code> 这个类还是一个 <code>Runnable</code> 实现，在 <code>Worker</code> 类通过 <code>ThreadFactory</code> 创建线程的时候，会把自己作为一个 <code>Runnable</code> 传给 <code>Thread</code> 所以，我们通过这个关系，就可以知道 <code>Worker</code> 和 <code>Thread</code> 的关联了。这样，我们通过 <code>ThreadPoolExecutor</code> 和 <code>Worker</code> 的关联，以及 <code>Worker</code> 和 <code>Thread</code> 的关联，就可以得到 <code>ThreadPoolExecutor</code> 和它创建的 <code>Thread</code> 的关联了。这个也就是线程和线程池的监控原理了。</p><p>最终终端 log 打印效果如下：</p><pre><code>com.xander.performace.demo W/demo_Issue: =================================================    type: THREAD    msg: THREAD POOL CREATE    create time: 2021-01-13 11:23:47    create trace:        com.xander.performance.StackTraceUtils.list(StackTraceUtils.java:39)        com.xander.performance.ThreadTool$ThreadPoolExecutorConstructorHook.afterHookedMethod(ThreadTool.java:158)        de.robv.android.xposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:265)        me.weishu.epic.art.entry.Entry64.onHookObject(Entry64.java:64)        me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:239)        java.util.concurrent.Executors.newSingleThreadExecutor(Executors.java:179)        com.xander.performance.demo.MainActivity.testThreadPool(MainActivity.kt:38)        java.lang.reflect.Method.invoke(Method.java:-2)        androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397)        android.view.View.performClick(View.java:7496)        android.view.View.performClickInternal(View.java:7473)        android.view.View.access$3600(View.java:831)        android.view.View$PerformClick.run(View.java:28641)        android.os.Handler.handleCallback(Handler.java:938)        android.os.Handler.dispatchMessage(Handler.java:99)        android.os.Looper.loop(Looper.java:236)        android.app.ActivityThread.main(ActivityThread.java:7876)        java.lang.reflect.Method.invoke(Method.java:-2)        com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)        com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)</code></pre><h2 id="IPC-进程间通讯-监控的原理"><a href="#IPC-进程间通讯-监控的原理" class="headerlink" title="IPC(进程间通讯)监控的原理"></a>IPC(进程间通讯)监控的原理</h2><p>进程间通讯的具体原理，也就是 <code>Binder</code> 机制，这里不做详细的说明，也不是这个框架库的原理。</p><p>检测进程间通讯的方法和前面检测线程的方法类似，就是找到所有的进程间通讯的方法的共同点，然后对共同点做一些修改或者说切片，让应用在进行进程间通讯的时候，打印一下调用栈，然后继续做原来的事情。就达到了 IPC 监控的目的。</p><p>那如何找到共同点，或者说切片，就是本节的重点。</p><p>进程间通讯离不开 <code>Binder</code> ，需要从 <code>Binder</code> 入手。</p><p>写一个 <code>AIDL</code> demo 后发现，自动生成的代码里面，接口 <code>A</code> 继承自 <code>IInterface</code> 接口，然后接口里面有个内部抽象类 <code>Stub</code> 类，继承自 <code>Binder</code> ，同时实现了接口 <code>A</code> 。这个 <code>Stub</code> 类里面还有一个内部类 <code>Proxy</code> ，实现了接口 <code>A</code> ，并持有一个 <code>IBinder</code> 实例。</p><p>我们在使用 <code>AIDL</code> 的时候，会用到 <code>Stub</code> 类的 <code>asInterFace</code> 的方法，这个方法会新建一个 <code>Proxy</code> 实例，并给这个 <code>Proxy</code> 实例传入 <code>IBinder</code> , 或者如果传入的 <code>IBinder</code> 实例如果是接口 <code>A</code> 的话，就强制转化为接口 A 实例。一般而言，这个 <code>IBinder</code> 实例是 <code>ServiceConnection</code> 的回调方法里面的实例，是 <code>BinderProxy</code> 的实例。所以 <code>Stub</code> 类的 <code>asInterFace</code> 一般会创建一个 <code>Proxy</code> 实例，查看这个 <code>Proxy</code> 接口的实现方法，发现最终都会调用 <code>BinderProxy</code> 的 <code>transact</code> 方法，所以 <code>BinderProxy</code> 的 <code>transact</code> 方法是一个很好的切入点。</p><p>本来我也是计划通过 <code>hook</code> 住 <code>BinderProxy</code> 类的 <code>transact</code> 方法来做 IPC 的检测的。但是 <code>epic</code> 库在 <code>hook</code> 含有 <code>Parcel</code> 类型参数的方法的时候，不稳定，会有异常。由于暂时还没能力解决这个异常，只能重新找切入点。最后发现 <code>AIDL</code> demo 生成的代码里面，除了调用了 调用 <code>BinderProxy</code> 的 <code>transact</code> 方法外，还调用了 <code>Parcel</code> 的 <code>readException</code> 方法，于是决定 <code>hook</code> 这个方法来切入 <code>IPC</code> 调用流程，从而达到 <code>IPC</code> 监控的目的。</p><p>最终终端 log 打印效果如下：</p><pre><code>com.xander.performace.demo W/demo_Issue: =================================================    type: IPC    msg: IPC    create time: 2021-01-13 11:25:04    trace:        com.xander.performance.StackTraceUtils.list(StackTraceUtils.java:39)        com.xander.performance.IPCTool$ParcelReadExceptionHook.beforeHookedMethod(IPCTool.java:96)        de.robv.android.xposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:229)        me.weishu.epic.art.entry.Entry64.onHookVoid(Entry64.java:68)        me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:220)        me.weishu.epic.art.entry.Entry64.voidBridge(Entry64.java:82)        android.app.IActivityManager$Stub$Proxy.getRunningAppProcesses(IActivityManager.java:7285)        android.app.ActivityManager.getRunningAppProcesses(ActivityManager.java:3684)        com.xander.performance.demo.MainActivity.testIPC(MainActivity.kt:55)        java.lang.reflect.Method.invoke(Method.java:-2)        androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397)        android.view.View.performClick(View.java:7496)        android.view.View.performClickInternal(View.java:7473)        android.view.View.access$3600(View.java:831)        android.view.View$PerformClick.run(View.java:28641)        android.os.Handler.handleCallback(Handler.java:938)        android.os.Handler.dispatchMessage(Handler.java:99)        android.os.Looper.loop(Looper.java:236)        android.app.ActivityThread.main(ActivityThread.java:7876)        java.lang.reflect.Method.invoke(Method.java:-2)        com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)        com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)</code></pre><h1 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h1><ul><li> Mail</li></ul><p><a href="mailto:&#52;&#x32;&#x30;&#x36;&#52;&#x30;&#55;&#x36;&#x33;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#52;&#x32;&#x30;&#x36;&#52;&#x30;&#55;&#x36;&#x33;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a></p><ul><li>微信</li></ul><p><img src="https://s3.ax1x.com/2021/01/30/yASVMD.jpg" class="lazyload placeholder" data-srcset="https://s3.ax1x.com/2021/01/30/yASVMD.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="微信"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><ol><li><a href="https://github.com/tiann/epic">epic</a></li><li><a href="https://github.com/ganyao114/SandHook">SandHook</a></li><li><a href="https://github.com/markzhai/AndroidPerformanceMonitor">AndroidPerformanceMonitor</a></li><li><a href="https://juejin.cn/post/6890407553457963022">面试官：如何监测应用的 FPS ？</a></li><li><a href="https://juejin.cn/post/6844904066259091469">深入探索Android卡顿优化（下）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结笔记(三) - Java 集合总结</title>
      <link href="/android-note/2021/02/07/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%B8%89)%20-%20Java%20%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
      <url>/android-note/2021/02/07/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%B8%89)%20-%20Java%20%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Java-集合总结"><a href="#Java-集合总结" class="headerlink" title="Java 集合总结"></a>Java 集合总结</h1><h2 id="Java-有哪些集合，继承关系是怎么样的"><a href="#Java-有哪些集合，继承关系是怎么样的" class="headerlink" title="Java 有哪些集合，继承关系是怎么样的"></a>Java 有哪些集合，继承关系是怎么样的</h2><p><img src="https://i.loli.net/2020/06/25/1WJPcAhjOQtyINo.png" class="lazyload placeholder" data-srcset="https://i.loli.net/2020/06/25/1WJPcAhjOQtyINo.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="集合框架图"></p><h2 id="平时常用的集合有哪些"><a href="#平时常用的集合有哪些" class="headerlink" title="平时常用的集合有哪些"></a>平时常用的集合有哪些</h2><ul><li>Collection<ul><li>List 可以重复添加元素<ul><li>ArrayList</li><li>LinkedList</li></ul></li><li>Set 不能重复添加元素<ul><li>HashSet 不接受 null </li><li>TreeSet</li></ul></li><li>Queue<ul><li>Deque</li><li>PriorityQueue 数组实现，堆</li><li>ArrayDeque 数组实现， 2 个游标</li></ul></li></ul></li><li>Map 以键值对的形式保存值<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeMap</li><li>Hashtable</li></ul></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>数组实现，初始容量为 10，不够的时候扩容，扩容就是数组在当前长度基础上增大一倍。添加数据的时候，先判断容量是否够，不够就扩容，扩容完成后再添加。</p><p>缺点: 线程不安全</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>链表实现。尾插法，即新节点插入到链表尾部。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>Java 1.8 底层基于 <code>HashMap</code> 实现，<code>HashMap</code> 的 <code>value</code> 都是同一个对象。</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>Java 1.8 默认是 <code>TreeMap</code> 实现，也可以给构造方法传入一个  <code>NavigableMap(接口)</code> 的实现实例。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p>双端队列，</p><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>堆，数组实现的</p><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>最常用的一种结构，以数组为基础，数组元素为链表的复合结构。</p><p>需要注意的是：</p><blockquote><p>初始容量为 16，默认承载因子为 0.75 ，需要注意的是，在指定容量的时候，如果不是 2 的指数，会计算一个大于指定容量，但是同时又是符合要求里面最小的一个 2 的指数作为容量。</p></blockquote><blockquote><p>当元素个数大于或等于(当前容量 * 承载因子)，就会扩容。</p></blockquote><blockquote><p>Java 1.7 插入数据的时候是头插法，即新的节点在链表头部。Java 1.8 及以后是尾插法，即新的节点在链表尾部。这个修改是为了解决扩容的时候可能会发生的死循环的问题。</p></blockquote><blockquote><p>Java 1.8 及以后，当同一个链表元素个数大于等于 (8 - 1) 的时候，会变成红黑树来存储，目的是提高效率。红黑树的转变是先比较 key 的 hash 大小，如果相同就尝试比较 key 自身。</p></blockquote><blockquote><p>无论是扩容，还是转成红黑树，都是先把节点放进去后再做扩容或者转换。</p></blockquote><blockquote><p>hash 碰撞，是指不同的 key, key 的 hash 和数组大小再次计算后,得出的索引一致。 hash 碰撞越少，HashMap 的效率越高。1.7 和 1.8 hash 算法有区别。</p></blockquote><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>基于 <code>HashMap</code> 实现的，同时还是一个双向循环链表(比 HashMap 的节点多了个 before 和 after 指针)，在开启排序的情况下，最近使用过的节点(put、get)会放在链表尾部。</p><p>这个特性很适合 <code>LRU</code> 算法的实现，大概原理就是 <code>LinkedHashMap</code> 开启排序，然后最近使用的元素都在链表<strong>尾部</strong>，当链表长度大于指定长度的时候，就从链表头部开始删除，因为链表头部是最近没有使用的。</p><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p><code>synchroinzed</code> 实现线程安全，效率低下。</p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 在 Java 1.8 底层实现是一个<strong>红黑树</strong>，排序的规则是比较 key 的 “大小”。并且要求 key 的类型是需要可以比较的，并且 key 值不能为 null。</p><p>和 <code>HashMap</code> 一样，先插入数据，然后在重排序。</p><h2 id="碰到的常见问题"><a href="#碰到的常见问题" class="headerlink" title="碰到的常见问题"></a>碰到的常见问题</h2><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>由于以上的都不是线程安全的，所以多线程的时候容易出问题，对于安全的线程有以下的几种</p><ul><li>List<ul><li>Vector 通过方法添加 <code>synchizoned</code> 关键字实现，效率低下。</li><li>CopyOnWriteArrayList <strong>每次</strong><code>写(添加，删除，修改)</code>的时候，都会生成一个新副本，所以频繁的写操作会消耗大量内存。</li></ul></li><li>Set<ul><li>CopyOnWriteArraySet 类似 CopyOnWriteArrayList</li></ul></li><li>Map<ul><li>ConcurrentHashMap  Java 1.7 是通过分段锁实现，Java 1.8 是 <code>CAS</code> 和 <code>synchroinzed</code> 实现</li></ul></li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>分段锁来实现，分段锁可以提高效率，是因为如果不同线程的读写发生在不同的段上，实际上是没有锁竞争的，也就是没有线程被阻塞，所以效率高。</p><h4 id="Java-1-7-及以前实现原理"><a href="#Java-1-7-及以前实现原理" class="headerlink" title="Java 1.7 及以前实现原理"></a>Java 1.7 及以前实现原理</h4><p>ConcurrentHashMap 有一个 segments 数组，这个数组元素的类型是 Segment，它继承自 ReentrantLock ，也就是说 Segment 是一个锁。</p><p>ConcurrentHashMap 插入或者修改数据的时候，会先找到是哪一个 segment , 然后在这个 segment 上面插入或者修改数据，而 segment 插入或者修改数据的时候，会先尝试获取锁，如果获取失败，说明有锁竞争，然后先尝试自旋，自旋超过次后，就开始阻塞线程。因此是线程安全的。</p><p>另外需要注意的是获取数据的时候没有加锁，因为是 <code>volatile</code> 变量，可以拿到最新的数据，但是呢，</p><h4 id="Java-1-8-及以后实现原理"><a href="#Java-1-8-及以后实现原理" class="headerlink" title="Java 1.8 及以后实现原理"></a>Java 1.8 及以后实现原理</h4><p>类似 HashMap ,放弃了分段锁，在插入或者修改数据的时候利用 cas 和 synchionzed 来保证线程安全，大概的原理就是先利用 cas 来设置，设置失败的时候说明有线程竞争，这个时候就用  synchionzed 来加锁，保证线程安全。</p><h4 id="Java-1-8-之后，为何放弃了分段锁"><a href="#Java-1-8-之后，为何放弃了分段锁" class="headerlink" title="Java 1.8 之后，为何放弃了分段锁"></a>Java 1.8 之后，为何放弃了分段锁</h4><p>分段后，数据不连续，碎片较多，内存浪费严重，扩容等操作耗费大量的时间。</p><p>Java 1.8 是用的 synchornized + HashMap 来做的， synchornized jvm 层做了优化，同时 HashMap 也做了红黑树的优化，所以效率方面有保障。</p><h2 id="主要方法总结"><a href="#主要方法总结" class="headerlink" title="主要方法总结"></a>主要方法总结</h2><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><pre><code>- add(E):boolean- add(int, E):boolean- remove(int):E- remove(E):boolean- size():int</code></pre><h4 id="Stack-类"><a href="#Stack-类" class="headerlink" title="Stack 类"></a>Stack 类</h4><p>继承自 Vector , Vector 是一个同步安全的 List</p><pre><code>- push(E):E 入栈- pop():E 出栈- peek():E 查看顶部第一个元素- search(Object):int- empty() 是否是空的</code></pre><h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><pre><code>- add(E):boolean- contains(Object):boolean- remove(Object):boolean- size():int</code></pre><h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><pre><code>- add 添加元素，返回添加结果，如果不能添加就抛出异常- remove 删除队列头，空队列异常- element 返回队列头，空队列异常- offer 添加元素，返回添加结果- poll 返回并删除队列头，空队列的话返回 null- peek 返回队列头，空队列的话返回 null</code></pre><h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><pre><code>- put(K, V):V- remove(Object):V- containsKey(Object):boolean- containsValue(Object):boolean- size():int</code></pre><h3 id="ArrayMap-和-HashMap"><a href="#ArrayMap-和-HashMap" class="headerlink" title="ArrayMap 和 HashMap"></a>ArrayMap 和 HashMap</h3><p>ArrayMap 有缓存， HashMap 没有</p><p>内存小</p><p><a href="http://gityuan.com/2019/01/13/arraymap/">深度解读ArrayMap优势与缺陷</a></p><p>SparseArray 和 ArrayList</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结笔记(二) - Java 反射和注解总结</title>
      <link href="/android-note/2021/02/07/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20-%20Java%20%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/"/>
      <url>/android-note/2021/02/07/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20-%20Java%20%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="反射总结"><a href="#反射总结" class="headerlink" title="反射总结"></a>反射总结</h1><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>反射是 Java 语言的一个特性，就是在程序运行状态中，对于任何一个类，都可以通过反射知道这个类所有的方法和属性。对于任何一个实例，都可以调用这个实例的任何方法和属性。这个<strong>在运行时动态获取类或者实例的属性和方法，动态调用属性和方法的特性</strong>就叫反射。</p><h2 id="反射有什么用"><a href="#反射有什么用" class="headerlink" title="反射有什么用"></a>反射有什么用</h2><p>从特性可以看出，在运行时可以动态调整属性的值和调用代码，可以让程序更灵活。主要用于以下几点</p><ul><li>动态创建实例( class.newInstance 方法 )</li><li>调用某个方法( method.invoke 方法 )</li><li>修改或者获取某个字段的值</li></ul><h3 id="反射的常用方法介绍"><a href="#反射的常用方法介绍" class="headerlink" title="反射的常用方法介绍"></a>反射的常用方法介绍</h3><h4 id="Class-常用方法介绍"><a href="#Class-常用方法介绍" class="headerlink" title="Class 常用方法介绍"></a>Class 常用方法介绍</h4><pre><code>getDeclaringClass  一般针对内部类，如 B 是 A 的内部类，在 B 的 class 上调用这个方法，返回的是 A getDeclaredClasses 获取当前类声明的内部类getClasses  包含当前类的父类和声明的 public 的内部类newInstance  创建一个类的实例forName 获取一个类，如果类没有加载会加载getConstructor 系列方法，可以获取构造方法类实例，然后调用实例的 newInstance 方法可以获得一个实例</code></pre><h4 id="Method-常用方法介绍"><a href="#Method-常用方法介绍" class="headerlink" title="Method 常用方法介绍"></a>Method 常用方法介绍</h4><pre><code>getMethod  获取 public 的方法，包括继承的getDeclaredMethod  该类里面的定义的方法，包括私有的和实现的接口的方法。invoke 该方法可以调用某个实例的某个方法。第一个参数为 null 时表示调用静态方法，第一个参数传入某个实例的时候，表示调用实例的某个方法。</code></pre><h4 id="Filed-常用方法介绍"><a href="#Filed-常用方法介绍" class="headerlink" title="Filed 常用方法介绍"></a>Filed 常用方法介绍</h4><pre><code>getField 获取字段getDeclaredField </code></pre><h2 id="常用的场景"><a href="#常用的场景" class="headerlink" title="常用的场景"></a>常用的场景</h2><h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>可以通过 <code>Class.forName</code> 方法加载指定的配置类，然后读取配置，以达到动态配置的效果。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理底层用到了反射。</p><h3 id="hook-框架"><a href="#hook-框架" class="headerlink" title="hook 框架"></a>hook 框架</h3><p>动态生成实例，修改字段值、调用非 <code>public</code> 方法</p><p>参考资料：</p><p><a href="https://www.zhihu.com/question/24304289">学习java应该如何理解反射？</a></p><h1 id="注解总结"><a href="#注解总结" class="headerlink" title="注解总结"></a>注解总结</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>注解是 JDK 1.5 引入的一个特性，用来给 Java 代码提供元数据。注解本身不直接影响代码的执行。</p><p>如何理解呢？<strong>注解是 Java 的一个特性，元数据可以理解为给编译器或者 jvm 看的++注释++，不直接影响程序的运行</strong>。但是可以在运行时通过读取注解做一些事情。可以把元数据理解为额外的一些可用可不用的额外信息。</p><h3 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h3><p>和定义接口类似，只不过关键字是 <code>@interface</code>。下面一段代码演示了如何定义个注解</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;    int id();    String msg();&#125;</code></pre><h2 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h2><ul><li>提供信息给编译器  这个接触的不多</li><li>编译阶段的处理    比如生产文档，这个有时候会用</li><li>运行时的处理   这个相对用的多，就是说运行时读取注解的值，来做一些事情，比如 Retrofit  框架库，就用到了注解。具体的原理分析在后续笔记记录。</li></ul><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/37701743">java注解-最通俗易懂的讲解</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 反射 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结笔记(一) - 泛型总结</title>
      <link href="/android-note/2020/07/23/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%B8%80)%20-%20%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/android-note/2020/07/23/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%B8%80)%20-%20%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型总结"><a href="#泛型总结" class="headerlink" title="泛型总结"></a>泛型总结</h1><h2 id="泛型是什么？"><a href="#泛型是什么？" class="headerlink" title="泛型是什么？"></a>泛型是什么？</h2><p>一句话说就是<strong>类型参数化</strong>。什么意思呢？<strong>参数化</strong>的意思就是我们在定义的时候不知道具体的值，我们在到我们实际运行的时候才知道具体的值。类型参数化就是具体类型在定义的时候不知道，在实际运行的时候是确定的某一个类型。</p><h2 id="Java-是如何实现泛型的？"><a href="#Java-是如何实现泛型的？" class="headerlink" title="Java 是如何实现泛型的？"></a>Java 是如何实现泛型的？</h2><p>泛型是很多高级语言都有的特性。根据定义，泛型在运行时表示同一个类型，我们比较容易想到 <code>List&lt;A&gt;</code> 和 <code>List&lt;B&gt;</code> 用 2 个不同的 Class 表示，这个是可行的，但是 Java 由于需要兼容支持旧的代码，而且在推出泛型前就提供了容器类，这种方式(<code>List&lt;A&gt;</code> 和 <code>List&lt;B&gt;</code> 用 2 个不同的 Class)无法兼容以前的老代码，所以这个实现方法不适用。所以 Java 大佬们想了另外一种方式来实现泛型,这种方式就是<code>类型擦除</code>。</p><h2 id="什么是泛型的类型擦除呢？"><a href="#什么是泛型的类型擦除呢？" class="headerlink" title="什么是泛型的类型擦除呢？"></a>什么是泛型的类型擦除呢？</h2><p>类型擦除就是在实际生成字节码的时候，编译器源码里面定义的 <code>List&lt;A&gt;</code> 变成了 <code>List&lt;Object&gt;</code>,源码里面定义的 <code>A Class</code> 被<code>擦除</code>了，变成了 <code>Object</code>，同时在使用的时候，会强制类型转换，把取出来的 <code>object</code> 转成 <code>A</code> 的实例去使用。这就是类型擦除。</p><p>初步看，泛型擦除好像是没什么大的问题，但是仔细想想，在强制类型转换的时候，由于会丢掉类型的一些信息，会导致一些不符合预期的事情。比如有个基类 A，和它的两个子类 B 和 C ，然后我们有下面的一段代码。</p><pre><code>List&lt;A&gt; listA = new ArrayList&lt;A&gt;();listA.add(new B()); // 错误的，</code></pre><p>第二行代码是不符合预期的，因为 <code>listA</code> 里面期望放的是 <code>A</code> 而不是 <code>B</code>。 但是这个好像不太符合预期，我们有时候希望子类是可以放进容器里面的。但是如果支持这个操作的话，会发生什么呢？取出来来的是 <code>B</code> 还是 <code>C</code> ？如果不能明确，那么就没有实现“泛型”。</p><p>为了解决这个问题， Java 大佬们想了个方法，提出了一些通配符来解决这些问题。</p><h2 id="泛型的通配符-、extends-和-super"><a href="#泛型的通配符-、extends-和-super" class="headerlink" title="泛型的通配符 ?、extends 和 super"></a>泛型的通配符 <code>?</code>、<code>extends</code> 和 <code>super</code></h2><p>在理解通配符之前，我们需要知道的是，通配符的发明是为了解决什么问题？至少要解决的一个问题是：容器里面放进去的是什么，取出来的就是什么。</p><p>这个问题，其实分两步，放进去，是说放进去同一种类型的东西。取出来，是说取出同一种类型的东西。或者说，用到通配符的地方应该是在不同的地方，一个地方把数据写到容器，另外一个地方把数据从容器拿出来，如果实在同一个代码块里写入和读取数据到同一个容器，应该是知道具体类型的，是不需要用到通配符的。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="? 通配符"></a><code>?</code> 通配符</h3><p><code>?</code> 通配符称为无限通配符，表示不确定或者不关心类型。</p><h3 id="extends-通配符"><a href="#extends-通配符" class="headerlink" title="extends 通配符"></a>extends 通配符</h3><p>一般称为上界通配符，表示的意思是：取值范围为 (某个类的子类, 某个类]。再想想我们之前说的，通配符要解决的问题？放进去的是什么，取出来的就应该是什么。放数据和取数据应用在不同的场景。</p><p>通过上面的表述，容易推断出来 <code>&lt;? extends E&gt;</code> 的集合只能往外拿数据，因为取出来的一定是 <code>E</code> ，但是放进去的不知道是什么，可能是 <code>E</code> ，也可能是 <code>E</code> 的子类，如果允许往集合里面放东西，就不能保证放进去的是什么，拿出来的就是什么了。因为只能保证拿出来的是 <code>E</code> 。</p><h3 id="super-通配符"><a href="#super-通配符" class="headerlink" title="super 通配符"></a>super 通配符</h3><p>一般称为下界通配符，表示的意思是：取值范围为 [某个类，这个类的父类)。结合上面小节的解释，可以推断出 <code>&lt;? super S&gt;</code> 的集合只能往里面放数据，而不能从里面拿东西，为什么呢？因为 <code>&lt;? extends E&gt;</code> 解决的就是拿出来的问题啊，所以这个解决的就是放进去的问题啊，囧。里面放的是下限或者下限的子类。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通配符与一个规则， <code>PE-CS</code>。</p><ul><li><p><code>PE</code> 是说，如果 T 表示的是一个生产者，应该用 <code>extends</code> 通配符。因为生产者有上限，比如生产笔的公司，上限就是能生产笔，但是不能生产布。</p></li><li><p><code>CS</code> 是说，如果某个集合表示一个消费者，应该用 <code>super</code> 通配符。因为消费者是有下限的，好比去买笔，购物车里面可以放铅笔、钢笔或者毛笔。这些下限就是笔，就是说都是笔。</p></li><li><p>同时作为生产者和消费者的情况不存在，因为你可以指定具体的泛型。</p></li></ul><p>参考资料：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1014635">深入理解 Java 泛型</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化总结</title>
      <link href="/android-note/2020/03/08/Android%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/android-note/2020/03/08/Android%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="性能优化总结"><a href="#性能优化总结" class="headerlink" title="性能优化总结"></a>性能优化总结</h2><p>性能的优化是一个老生常谈的点，也是一个比较重要的点。现在对工作中的优化点做一个总结。</p><h3 id="优化的方向，即那些点是需要优化的"><a href="#优化的方向，即那些点是需要优化的" class="headerlink" title="优化的方向，即那些点是需要优化的"></a>优化的方向，即那些点是需要优化的</h3><p>在平时的优化过程中我们需要从哪几个点来优化呢？其实我们平时自己一定也用过软件，在使用软件的过程中有没有什么想吐槽的呢？<br>“太卡了吧！”、”图片怎么还没加载出来？”、”怎么刚进去就卡了。”等等，是不是有这样的想法，这些想法其实包含了我们今天要说的<br>内容，就是从哪些方面来优化我们的 APP ，我总结了以下几点。</p><ul><li>启动速度</li><li>操作流畅度</li><li>内存的管理和使用</li><li>图片的加载</li></ul><p>当然，需要优化的不仅仅是这几个方面，我们暂时先就这几个方面来谈谈优化吧</p><h3 id="启动速度"><a href="#启动速度" class="headerlink" title="启动速度"></a>启动速度</h3><p>启动速度是一个很关键的点，相信平时大家在使用软件的时候，如果点了应用的图标，结果很久才能进入主界面，很久才能操作。<br>那么这个应用大概率会被卸载。</p><p>那我们如何优化我们的 APP 的启动速度呢？</p><p>首先，第一步我们要知道我们的应用启动花的时间，</p><h3 id="操作流畅度"><a href="#操作流畅度" class="headerlink" title="操作流畅度"></a>操作流畅度</h3><h3 id="内存的管理和使用"><a href="#内存的管理和使用" class="headerlink" title="内存的管理和使用"></a>内存的管理和使用</h3><h3 id="图片的加载"><a href="#图片的加载" class="headerlink" title="图片的加载"></a>图片的加载</h3>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 学习大纲总结</title>
      <link href="/android-note/2020/02/16/Android%20%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2%E6%80%BB%E7%BB%93/"/>
      <url>/android-note/2020/02/16/Android%20%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E6%88%91%E7%9A%84-android-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">我的 Android 学习笔记</a><ul><li><a href="#java-%E5%9F%BA%E7%A1%80">Java 基础</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B">基础类型</a></li><li><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">循环控制</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88">常见集合</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a><ul><li><a href="#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="#%E9%98%9F%E5%88%97">队列</a></li><li><a href="#%E9%93%BE%E8%A1%A8">链表</a></li><li><a href="#%E6%A0%88">栈</a></li><li><a href="#%E5%AD%97%E5%85%B8">字典</a></li><li><a href="#%E6%A0%91">树</a></li></ul></li></ul></li><li><a href="#%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6">基础控件</a><ul><li><a href="#%E4%BA%94%E7%A7%8D-layout">五种 Layout</a></li><li><a href="#imageview">ImageView</a></li><li><a href="#listview">ListView</a></li><li><a href="#recyclerview">RecyclerView</a></li><li><a href="#dialog">Dialog</a></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6">自定义控件</a><ul><li><a href="#%E6%B5%81%E7%A8%8B">流程</a></li><li><a href="#%E5%B1%9E%E6%80%A7%E8%87%AA%E5%AE%9A%E4%B9%89">属性自定义</a></li><li><a href="#canvas">Canvas</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E4%B8%8B%E5%8F%91">事件下发</a></li></ul></li><li><a href="#%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6">四大组件</a><ul><li><a href="#activity">Activity</a></li><li><a href="#service">Service</a></li><li><a href="#provider">Provider</a></li><li><a href="#broadcast">Broadcast</a></li></ul></li><li><a href="#%E5%A4%9A%E5%AA%92%E4%BD%93">多媒体</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a><ul><li><a href="#jetpack">Jetpack</a></li><li><a href="#%E5%8A%A8%E7%94%BB">动画</a></li><li><a href="#handler">Handler</a></li><li><a href="#asynctask">AsyncTask</a></li><li><a href="#manifast">Manifast</a></li><li><a href="#%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">跨进程通信</a></li><li><a href="#%E4%BF%9D%E6%B4%BB">保活</a></li></ul></li><li><a href="#%E4%BC%A0%E6%84%9F%E5%99%A8">传感器</a><ul><li><a href="#%E9%9C%87%E5%8A%A8">震动</a></li><li><a href="#%E6%AD%A5%E6%95%B0">步数</a></li><li><a href="#%E6%8C%87%E5%8D%97%E9%92%88">指南针</a></li></ul></li><li><a href="#framework">FrameWork</a><ul><li><a href="#ams">AMS</a></li><li><a href="#pms">PMS</a></li><li><a href="#wms">WMS</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6">常用框架</a><ul><li><a href="#%E5%9B%BE%E7%89%87">图片</a></li><li><a href="#%E7%BD%91%E7%BB%9C">网络</a></li><li><a href="#%E5%BC%82%E6%AD%A5">异步</a></li><li><a href="#%E7%BB%84%E4%BB%B6%E5%8C%96">组件化</a></li><li><a href="#%E6%8F%92%E4%BB%B6%E5%8C%96">插件化</a></li></ul></li><li><a href="#%E7%AE%97%E6%B3%95">算法</a><ul><li><a href="#%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">八种排序算法</a></li></ul></li><li><a href="#%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90">书籍推荐</a></li></ul></li></ul><!-- /TOC --><h1 id="我的-Android-学习笔记"><a href="#我的-Android-学习笔记" class="headerlink" title="我的 Android 学习笔记"></a>我的 Android 学习笔记</h1><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p><a href="https://blog.csdn.net/u014266877/article/details/54374867">Java 八大基本数据类型</a></p><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p><a href="https://blog.csdn.net/from_heat/article/details/82289626">Java控制语句</a></p><h3 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h3><p><a href="https://blog.csdn.net/Dante_003/article/details/79418369">java常用集合类及其区别、源码分析（一）</a></p><p><a href="https://www.jianshu.com/p/b54f1df33f84">JAVA集合框架中的常用集合及其特点、适用场景、实现原理简介</a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><a href="https://www.cnblogs.com/ok932343846/p/6743699.html">Java数组的定义和使用</a></p><p><a href="https://www.cnblogs.com/mengdd/archive/2013/01/04/2844264.html">Java 数组基础</a></p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><a href="https://blog.csdn.net/u011240877/article/details/52860924">Java 集合深入理解（9）：Queue 队列</a></p><p><a href="https://www.cnblogs.com/lemon-flm/p/7877898.html">java队列——queue详细分析</a></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p><a href="https://blog.csdn.net/jianyuerensheng/article/details/51200274">【数据结构】链表的原理及java实现</a></p><p><a href="https://www.jianshu.com/p/904c2cfb5ef0">Java链表实现以及链表倒置</a></p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><a href="https://blog.csdn.net/top_code/article/details/8650910">Java 数据结构之 Stack(栈)</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/53362993">java数据结构与算法之栈（Stack）设计与实现</a></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p><a href="https://www.cnblogs.com/lzq198754/p/5780165.html">Java map 详解 - 用法、遍历、排序、常用API等</a></p><p><a href="https://blog.csdn.net/qq_33642117/article/details/52049764">Java Map集合的详解</a></p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p><a href="https://www.cnblogs.com/MyStringIsNotNull/p/8279126.html">K：树、二叉树与森林之间的转换及其相关代码实现</a></p><h2 id="基础控件"><a href="#基础控件" class="headerlink" title="基础控件"></a>基础控件</h2><h3 id="五种-Layout"><a href="#五种-Layout" class="headerlink" title="五种 Layout"></a>五种 Layout</h3><h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h3><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h3 id="属性自定义"><a href="#属性自定义" class="headerlink" title="属性自定义"></a>属性自定义</h3><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><h3 id="事件下发"><a href="#事件下发" class="headerlink" title="事件下发"></a>事件下发</h3><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h3><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h3><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><h3 id="Manifast"><a href="#Manifast" class="headerlink" title="Manifast"></a>Manifast</h3><h3 id="跨进程通信"><a href="#跨进程通信" class="headerlink" title="跨进程通信"></a>跨进程通信</h3><h3 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h3><h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><h3 id="震动"><a href="#震动" class="headerlink" title="震动"></a>震动</h3><h3 id="步数"><a href="#步数" class="headerlink" title="步数"></a>步数</h3><h3 id="指南针"><a href="#指南针" class="headerlink" title="指南针"></a>指南针</h3><h2 id="FrameWork"><a href="#FrameWork" class="headerlink" title="FrameWork"></a>FrameWork</h2><h3 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h3><h3 id="PMS"><a href="#PMS" class="headerlink" title="PMS"></a>PMS</h3><h3 id="WMS"><a href="#WMS" class="headerlink" title="WMS"></a>WMS</h3><h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="八种排序算法"><a href="#八种排序算法" class="headerlink" title="八种排序算法"></a>八种排序算法</h3><h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
